# Copyright 2024 Bytedance Ltd. and/or its affiliates
# Copyright 2023-2024 SGLang Team
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import logging
import threading
import time
import traceback
import uuid
from typing import Any, Optional

import requests
from enum import Enum

class QueryType(str, Enum):
    AMAP_INPUT_TIPS = "amap_input_tips"
    AMAP_KEYWORD_SEARCH = "amap_keyword_search"
    AMAP_POI_DETAIL = "amap_poi_detail"
    GOOGLEMAP_SEARCH = "google_map_search"
    GOOGLE_SEARCH = "google_search"

DEFAULT_TIMEOUT = 30  # Default search request timeout
MAX_RETRIES = 10
INITIAL_RETRY_DELAY = 1
API_TIMEOUT = 10

logger = logging.getLogger(__name__)


def call_api(
    url: str,
    query: str,
    query_type: QueryType,
    return_scores: bool = True,
    timeout: int = DEFAULT_TIMEOUT,
) -> tuple[Optional[dict[str, Any]], Optional[str]]:
    """
    Calls the specific API to perform retrieval with retry logic for various errors,
    using increasing delay between retries. Logs internal calls with a unique ID.

    Args:
        url: The URL of the API.
        query: query.
        query_type: API type.
        return_scores: Whether to return scores.
        timeout: Request timeout in seconds.

    Returns:
        A tuple (response_json, error_message).
        If successful, response_json is the API's returned JSON object, error_message is None.
        If failed after retries, response_json is None, error_message contains the error information.
    """
    request_id = str(uuid.uuid4())
    log_prefix = f"[API call Request ID: {request_id}] "

    if query_type == QueryType.AMAP_INPUT_TIPS:
        payload = {
            "query": query,
        }
    elif query_type == QueryType.AMAP_KEYWORD_SEARCH:
        payload = {
            "query": query,
        }
    elif query_type == QueryType.AMAP_POI_DETAIL:
        payload = {
            "query": query,
        }
    elif query_type == QueryType.GOOGLE_SEARCH:
        payload = {
            "query": query,
        }
    elif query_type == QueryType.GOOGLEMAP_SEARCH:
        payload = {
            "query": query,
        }
    else:
        raise NotImplementedError

    headers = {"Content-Type": "application/json"}

    last_error = None

    for attempt in range(MAX_RETRIES):
        try:
            logger.info(
                f"{log_prefix}Attempt {attempt + 1}/{MAX_RETRIES}: Calling {query_type} API at {url}"
            )
            response = requests.post(
                url,
                headers=headers,
                json=payload,
                timeout=timeout,
            )

            # Check for Gateway Timeout (504) and other server errors for retrying
            if response.status_code in [500, 502, 503, 504]:
                last_error = (
                    f"{log_prefix}API Request Error: Server Error ({response.status_code}) on attempt "
                    f"{attempt + 1}/{MAX_RETRIES}"
                )
                logger.warning(last_error)
                if attempt < MAX_RETRIES - 1:
                    delay = INITIAL_RETRY_DELAY * (attempt + 1)
                    logger.info(f"{log_prefix}Retrying after {delay} seconds...")
                    time.sleep(delay)
                continue

            # Check for other HTTP errors (e.g., 4xx)
            response.raise_for_status()

            # If successful (status code 2xx)
            logger.info(f"{log_prefix} {query_type} API call successful on attempt {attempt + 1}")
            return response.json(), None

        except requests.exceptions.ConnectionError as e:
            last_error = f"{log_prefix}Connection Error: {e}"
            logger.warning(last_error)
            if attempt < MAX_RETRIES - 1:
                delay = INITIAL_RETRY_DELAY * (attempt + 1)
                logger.info(f"{log_prefix}Retrying after {delay} seconds...")
                time.sleep(delay)
            continue
        except requests.exceptions.Timeout as e:
            last_error = f"{log_prefix}Timeout Error: {e}"
            logger.warning(last_error)
            if attempt < MAX_RETRIES - 1:
                delay = INITIAL_RETRY_DELAY * (attempt + 1)
                logger.info(f"{log_prefix}Retrying after {delay} seconds...")
                time.sleep(delay)
            continue
        except requests.exceptions.RequestException as e:
            last_error = f"{log_prefix}API Request Error: {e}"
            break  # Exit retry loop on other request errors
        except json.JSONDecodeError as e:
            raw_response_text = response.text if "response" in locals() else "N/A"
            last_error = f"{log_prefix}API Response JSON Decode Error: {e}, Response: {raw_response_text[:200]}"
            break  # Exit retry loop on JSON decode errors
        except Exception as e:
            last_error = f"{log_prefix}Unexpected Error: {e}"
            break  # Exit retry loop on other unexpected errors

    # If loop finishes without returning success, return the last recorded error
    logger.error(f"{log_prefix} {query_type} API call failed. Last error: {last_error}")
    return None, last_error.replace(log_prefix, "API Call Failed: ") if last_error else "API Call Failed after retries"


def perform_api_call(
    url: str,
    query: str,
    query_type: QueryType,
    concurrent_semaphore: Optional[threading.Semaphore] = None,
    timeout: int = DEFAULT_TIMEOUT,
) -> tuple[str, dict[str, Any]]:
    """
    Performs a single batch search for multiple queries (original search tool behavior).

    Args:
        url: The URL of API.
        query: query.
        query_type: 
        concurrent_semaphore: Optional semaphore for concurrency control.
        timeout: Request timeout in seconds.

    Returns:
        A tuple (result_text, metadata).
        result_text: The result JSON string.
        metadata: Metadata dictionary for the batch search.
    """
    logger.info(f"Starting api call for {query_type}: {query}")

    api_response = None
    error_msg = None

    try:
        if concurrent_semaphore:
            with concurrent_semaphore:
                api_response, error_msg = call_api(
                    url=url,
                    query=query,
                    query_type=query_type,
                    return_scores=True,
                    timeout=timeout,
                )
        else:
            api_response, error_msg = call_api(
                url=url,
                query=query,
                query_type=query_type,
                return_scores=True,
                timeout=timeout,
            )
    except Exception as e:
        error_msg = f"API Request Exception during api call: {e}"
        logger.error(f"API Call: {error_msg}")
        traceback.print_exc()

    metadata = {
        "query_type": query_type,
        "query": query,
        "api_request_error": error_msg,
        "api_response": None,
        "status": "unknown",
        "total_results": 0,
        "formatted_result": None,
    }

    result_text = json.dumps({"result": "API call failed or timed out after retries."}, ensure_ascii=False)

    if error_msg:
        metadata["status"] = "api_error"
        result_text = json.dumps({"result": f"{query_type} API call error: {error_msg}"}, ensure_ascii=False)
        logger.error(f"{query_type}: API error occurred: {error_msg}")
    elif api_response:
        logger.debug(f"{query_type}: API Response: {api_response}")
        metadata["api_response"] = api_response

        try:
            if query_type == QueryType.AMAP_INPUT_TIPS:
                pretty_results = []
                total_results = 0
                for tip in api_response.get("tips", []):
                    pretty_results.append((
                        f"id: {poi.get('id')}\n"
                        f"name: {poi.get('name')}\n"
                        f"address: {poi.get('address')}\n"
                        f"typecode: {poi.get('typecode')}\n"
                        f"city: {poi.get('city')}\n"
                    ))
                    total_results += 1
            elif query_type == QueryType.AMAP_KEYWORD_SEARCH:
                pretty_results = []
                total_results = 0
                for poi in api_response.get("pois", []):
                    pretty_results.append((
                        f"id: {poi.get('id')}\n"
                        f"name: {poi.get('name')}\n"
                        f"address: {poi.get('address')}\n"
                        f"typecode: {poi.get('typecode')}\n"
                    ))
                    total_results += 1
            elif query_type == QueryType.AMAP_POI_DETAIL:
                pretty_results = []
                total_results = 0
                if api_response.get("pois", []):
                    pretty_results.append((
                        f"id: {poi.get('id')}\n"
                        f"name: {poi.get('name')}\n"
                        f"location: {poi.get('location')}\n"
                        f"address: {poi.get('address')}\n"
                        f"business_area: {poi.get('business_area')}\n"
                        f"city: {poi.get('city')}\n"
                        f"type: {poi.get('type')}\n"
                        f"alias: {poi.get('alias')}\n"
                    ))
                    total_results = 1
            elif query_type == QueryType.GOOGLEMAP_SEARCH:
                pretty_results = []
                total_results = 0
                for place in api_response.get("places", []):
                    pretty_results.append((
                        f"title: {place.get('title')}\n"
                        f"Address: {place.get('Address')}\n"
                        f"latitude: {place.get('latitude', '')}\n"
                        f"longitude: {place.get('longitude', '')}\n"
                        f"Type: {', '.join(place.get('types', []))}\n"
                    ))
                    total_results += 1
            elif query_type == QueryType.GOOGLE_SEARCH:
                pretty_results = []
                total_results = 0
                for result in api_response:
                    pretty_results.append(result)
                    total_results += 1
                
            final_result = "\n---\n".join(pretty_results)
            
            result_text = json.dumps({"result": final_result}, ensure_ascii=False)
            metadata["status"] = "success"
            metadata["total_results"] = total_results
            metadata["formatted_result"] = final_result
            logger.info(f"Batch search: Successful, got {total_results} total results")

        except Exception as e:
            error_msg = f"Error processing {query_type} api call results: {e}"
            result_text = json.dumps({"result": error_msg}, ensure_ascii=False)
            metadata["status"] = "processing_error"
            logger.error(f"{query_type} api call: {error_msg}")
    else:
        metadata["status"] = "unknown_api_state"
        result_text = json.dumps(
            {"result": "Unknown API state (no response and no error message)."}, ensure_ascii=False
        )
        logger.error(f"{query_type} api call: Unknown API state.")

    return result_text, metadata


